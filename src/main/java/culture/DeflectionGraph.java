package culture;import java.awt.Canvas;import java.awt.Color;import java.awt.Dimension;import java.awt.Font;import java.awt.FontMetrics;import java.awt.Graphics;/** Routine for drawing the deflection-over-time graph. */public class DeflectionGraph extends Canvas {	static final int BORDER = 4;	public DeflectionGraph() { // Constructor method.	}	public void paint(Graphics g) { // Paint the graph.		String[] xLabels;		String[] yLabels = { "", "10", "20", "30" };		double maxD;		int x0, y0, xMax, yMax, width, height;		DataList events;		String graphTitle;		int plotHeight, plotWidth, plotTop, plotBottom, plotLeft, plotRight;		int increment, labelPosition, boundary, positionY, lastPositionX, lastPositionY;		int titleAreaHeight, xLabelAreaHeight, leftIndent;		int tick = 4;		int viewer, eventNow;		double[] deflections;		float[] p = { 0, (float) .7, (float) .8, (float) .9, 1 };		double currentEventDeflection;		// Assemble data and graphic parameters.		viewer = Interact.viewer;		events = Interact.person[viewer].serialEvents;		eventNow = Interact.analyzeEvents.eventList.getSelectedIndex() + 1;		deflections = new double[eventNow];		if (eventNow > 0) {			currentEventDeflection =				Math.round(10.0 * ((EventRecord) events.elementAt(eventNow - 1)).deflection) / 10.0;		} else {			currentEventDeflection = 0.0;		}		maxD = 0;		for (int i = 0; i < eventNow; i++) {			deflections[i] =				Math.round(10.0 * ((EventRecord) events.elementAt(i)).deflection) / 10.0;			maxD = Math.max(maxD, deflections[i]);		}		// Define zeropoints and dimensions.		x0 = BORDER;		y0 = BORDER / 2;		xMax = this.getBounds().width - BORDER;		yMax = this.getBounds().height - BORDER;		width = xMax - x0;		height = yMax - y0;		// Set texts.		if (eventNow > 0) {			// Title is Deflection =.			graphTitle =				Interact.InteractText.getString("deflection") + " = "					+ (new Double(currentEventDeflection)).toString();		} else if (Interact.analyzeEvents.eventList.getItemCount() > 0) {			// Title is instruction to click event.			graphTitle = Interact.InteractText.getString("clickEvent");		} else {			// Title says no events.			graphTitle = Interact.InteractText.getString("noEvents");		}		xLabels = new String[eventNow];		for (int i = 0; i < eventNow; i++) {			if (eventNow < 15) {				// Label every event in short series, else every tenth event.				xLabels[i] = (new Integer(i + 1)).toString();			} else {				if (Math.IEEEremainder(i, 10) == 0) {					xLabels[i] = (new Integer(i)).toString();				} else {					xLabels[i] = " ";				}			}		}		// Define area dimensions.		Font typeFace = new Font("SansSerif", Font.PLAIN, 10);		g.setFont(typeFace);		FontMetrics typeMetrics = g.getFontMetrics();		leftIndent = typeMetrics.stringWidth("30") + tick + x0 + 2;		typeFace = new Font("SansSerif", Font.BOLD, 10);		g.setFont(typeFace);		typeMetrics = g.getFontMetrics();		titleAreaHeight = typeMetrics.getHeight();		g.setColor(Color.black);		g.drawString(graphTitle,			(width - typeMetrics.stringWidth(graphTitle) + leftIndent) / 2,			typeMetrics.getAscent() + y0);		typeFace = new Font("SansSerif", Font.PLAIN, 10);		g.setFont(typeFace);		typeMetrics = g.getFontMetrics();		xLabelAreaHeight = typeMetrics.getHeight() + tick + 2;		plotTop = titleAreaHeight + y0;		plotHeight = height - plotTop - xLabelAreaHeight;		plotBottom = plotTop + plotHeight;		plotLeft = leftIndent;		plotRight = width;		plotWidth = plotRight - plotLeft;		// Add interpretative color bands.		increment = plotHeight / 4;		g.setColor(new Color(p[4], p[2], p[2])); // Pink.		g.fillRect(plotLeft, plotTop, plotWidth, increment);		g.setColor(new Color(p[4], p[3], p[2])); // Pastel orange.		g.fillRect(plotLeft, plotTop + increment, plotWidth, increment);		g.setColor(new Color(p[4], p[4], p[2])); // Pastel yellow.		g.fillRect(plotLeft, plotTop + 2 * increment, plotWidth, increment);		g.setColor(new Color(p[3], p[4], p[2])); // Pastel chartreuse.		g.fillRect(plotLeft, plotTop + 3 * increment, plotWidth, plotHeight - 3			* increment);		// Vertical axis labels.		g.setColor(Color.black);		increment = plotHeight / 3;		labelPosition = plotTop;		boundary = leftIndent - tick - 1;		for (int i = 3; i > 0; i--) {			g.drawString(yLabels[i],				boundary - typeMetrics.stringWidth(yLabels[i]), labelPosition					+ typeMetrics.getAscent() / 2);			g.drawLine(leftIndent - tick, labelPosition, leftIndent,				labelPosition);			labelPosition = labelPosition + increment;		}		// Axes.		g.drawLine(plotLeft, plotTop, plotLeft, plotBottom);		g.drawLine(plotLeft, plotBottom, plotRight, plotBottom);		// Horizontal labels, and data plot.		labelPosition = plotLeft;		if (eventNow > 0) {			increment = (plotRight - plotLeft) / (eventNow + 1);		} else {			increment = 0;		}		lastPositionX = lastPositionY = 0;		for (int i = 0; i < eventNow; i++) {			labelPosition = labelPosition + increment;			g.setColor(Color.black);			g.drawString(xLabels[i],				labelPosition - typeMetrics.stringWidth(xLabels[i]) / 2, height);			g.drawLine(labelPosition, plotBottom, labelPosition, plotBottom				+ tick);			// Plot deflections.			positionY =				plotTop + (int) (plotHeight * (1 - (deflections[i] / 30)));			g.setColor(Color.blue);			if (eventNow == 1) {				g.fillRect(labelPosition - 1, positionY - 1, 3, 3);			} else if (i > 0) {				g.drawLine(lastPositionX, lastPositionY, labelPosition,					positionY);			}			lastPositionX = labelPosition;			lastPositionY = positionY;		}	} // End Paint.	public Dimension getPreferredSize() {		return new Dimension(100, 135);	}} // End class Graph.